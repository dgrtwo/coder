---
title: "Classcodes objects"
output: 
  rmarkdown::html_vignette:
    df_print: tibble
vignette: >
  %\VignetteIndexEntry{Classcodes objects}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(coder)
```

# Motivating example

Let's consider some patients (from a research study) ...\

```{r}
ex_people
```

... and their corresponding diagnostics data (from a national patient register):\

```{r}
ex_icd10
```

Lets categorize those patients by their Charlson comorbidity:

```{r}
categorize(
  ex_people, 
  codedata = ex_icd10, 
  cc   = charlson, 
  id   = "name", 
  code = "icd10"
)
```

Here, `charlson` (as supplied by the `cc` argument) is a "classcodes" object containing a classification scheme. This is the specification of how to match patient codes (from `codedata`) to groups (comorbidity conditions). It is based on regular expressions which recognize all codes for each group.

# Default classcodes

There are `r nrow(all_classcodes())` default "classcodes" objects in the package (`classcodes` column below). Each of them might have several versions of regular expressions (column `regex`) and weighted indices (column `indices`):

```{r}
all_classcodes()
```

# classcodes object

Each of those classcodes objects are documented (see for example `?charlson`). The object is basically a `tibble` (data frame) with some additional attributes (and a print method to present those):

```{r}
charlson
```

Columns have pre-specified names and/or content:

-   `group`: short descriptive names of all groups to classify by (i.e. medical conditions/comorbidities).
-   `description:` (optional) additional details describing each group.
-   regular expressions identifying each group (see `?charlson` for details). Multiple versions might be used if combined with different code sets (i.e. ICD-9 versus ICD-10). (Column names are arbitrary but identified by `attr(., "regexprs").`)
-   numeric vectors used as weights when calculating index sums based on all (or a subset of) individual groups. (Column names are arbitrary but identified by `attr(., "indices")`.)
-   `condition`: (optional; not used with `charlson`) conditional classification (see for example `?hip_ae`).

In the example above, we did not specify which version of regular expression to use. We see from the printed output above (or by `attr(charlson, "regexprs")`), that the first regular expression is "icd10". This will be used by default. We have ICD-10 codes recorded in our code data set (`ex_icd10$icd10`). We might therefore use either "icd10" or "icd10\_rcs" to classify those. Other versions might be relevant if the medical data is coded by other codes (such as earlier versions of ICD). We will show below how to alter this setting in practice.

# Hierarchy

Some classcodes objects have an additional class attribute "hierarchy", controlling hierarchical groups where only one of possibly several groups (occurring simultaneity) should be used in weighted index sums. This is true for Elixhauser:\

```{r}
print(elixhauser, n = 0) # preview 0 rows
```

This means that patients who have both metastatic cancer and solid tumors should be recognized as such if classified. If such patient are assigned an aggregated index score, however, only the largest score is used (in this case for a metastatic cancer as superior to a solid tumor). The same is true for patients diagnosed with both uncomplicated and complicated diabetes.

# Interpret regular expressions

## Visualize

Regular expressions might be difficult to interpret and can therefore be `visualize()`:d. This will open a web page in the default browser (not displayed here).

```{r, eval = FALSE}
visualize(charlson)
```

Visualization of all groups simultaneously might lead to complex figures. We can focus on a specific group (comorbidity) by the `group` argument. How is `r charlson$group[1]` codified by `regex_icd9cm_deyo`?

```{r, eval = FALSE}
visualize(
  charlson, 
  group    = "myocardial infarction", 
  regex    = "icd9cm_deyo"
)
```

```{r, echo = FALSE}
knitr::include_graphics("regexp_charlson_ci_icd9.png")

```

Hence, all codes starting with `41` followed by either `0` or `2` will be recognized as myocardial infarction according to `icd9cm_deyo`. The corresponding regular expression for ICD-10 is:

```{r, eval = FALSE}
visualize(
  charlson, 
  group    = "myocardial infarction",
  regex    = "icd10"
)
```

```{r, echo = FALSE}
knitr::include_graphics("regexp_charlson_ci_icd10.png")

```

Such codes should start with `I2` followed by either `1`, `2` or `52`. The vertical bar `|` (in the regular expression of the heading) indicates a logical "or". See `?regex` for more details on how to use regular expressions in R (not that Perl-like versions are currently not allowed).

## List all codes

An alternative representation is to list all relevant codes identified by each regular expression. This is implemented by the `summary()` method for classcodes objects. Note, however, that the regular expressions are stand alone in each classcodes object. Hence, there are no static look-up-tables to map individual codes to each group. We therefore need to specify a code list/dictionary of all possible codes to be recognized by those regular expressions. Then `summary()`will categorize those and display the result. Common code lists are found in the `{decoder}` package ([https://cancercentrum.bitbucket.io/decoder/)](https://cancercentrum.bitbucket.io/decoder/)) and are accessed automatically through the `coding` argument to `summary()`. Hence, there is a " keyvalue" object with all ICD-10-CM codes in `{decoder}:`

```{r}
decoder::icd10cm

```

We can use this code list to identify all codes recognized by `charlson` (and its default classification based on "icd10"). The printed result (see `? print.summary.classcodes`) is a tibble with each group and a comma separated code list.

```{r}
s <- summary(charlson, coding = "icd10cm")
s
```

A list with all code vectors (to use for programmatic purposes) is also returned (invisible) and accessed by `s$codes_vct`.

Now, compare the result above with the output based on a different code list, namely ICD-10-SE, the Swedish version of ICD-10, instead of ICD-10-CM:

```{r}
summary(charlson, coding = "icd10se")
```

There are some noticeable differences. AIDS/HIV for example has only one code deemed clinically relevant in the USA (thus included in the CM-version of ICD-10), although there are 22 different codes potentially used in the Swedish national patient register. There are additional differences concerning the fifth code position (digits in ICD-10-CM and characters in ICD-10-SE). Those mark national modifications to the original ICD-10 codes, which has only 4 positions (one character and three digits). For this example, the `charlson$icd10` column was based on ICD-10-CM [@Quan2005]. The comparison above thus highlights potential differences when using this classification in a setting based on another classification (such as with data from the Swedish national patient register).

## Codebooks

Even with individual codes summarized, those might still be hard to interpret on their own. The [decoder](https://cancercentrum.bitbucket.io/decoder/) package can help to translate codes to readable names/description. This is facilitated by the `codebook()` function in the `{coder}`package.

The main purpose is to export an Excel-file (if path specified by argument `file`). The output is otherwise a list, including both a summary table (described above) and a tibble with "all\_codes" explaining the meaning of each code to be recognized by the regular expression.

We can compare the codes recognized as AIDS/HIV by either ICD-10-CM or ICD-10-SE:

```{r}

cm <- codebook(charlson, "icd10cm")$all_codes
cm[cm$group == "AIDS/HIV", ]

se <- codebook(charlson, "icd10se")$all_codes
se[se$group == "AIDS/HIV", ]

```

## Combined codebooks

Several codebooks can be combined (exported to a single Excel-file) by the function `codebooks()` (note the plural s).

# Alternative classifications

Examples above use the default regex column (currently ICD-10). If we are interested in another version, for example specified by Deyo et al. based on ICD-9-CM, this can be specified by the `regex`-argument passed by the `cc_args` argument to the `set_classcodes` function. Simultaneously, the `coding` argument is set to `icd9cmd` to match the regular expressions to the disease part of ICD-9-CM classification.

```{r}
summary(
  charlson, coding = "icd9cmd",
  cc_args = list(regex = "icd9cm_deyo")
)
```

# Use classcodes objects

Most functions do not use the classcodes object themselves, but a modified version passed through `set_classcodes()`. This function can be called directly but is more often invoked by arguments passed by the `cc_args` argument used in other functions (as in the example above).

## Explicit use of `set_classcodes()`

We might call `set_classcodes()`directly to prepare a classification scheme to classify patients according to the Charlson comorbidity index. The diagnoses data might be coded by the legacy classification ICD-8 (as suggested by Brusselaers et al. 2015). Such codes might be found in character strings with leading prefixes or in the middle of a more verbatim description. This is controlled by setting the argument `start = FALSE`, meaning that the identified ICD-8 codes do not need to appear in the beginning of each string. We might assume, however, that there is no more information after the code (as specified by `stop = TRUE`).

```{r}
charlson_icd8 <- 
  set_classcodes(
    "charlson",
    regex = "icd8_brusselaers", # Version based on ICD-8
    start = FALSE, # Codes do not have to occur in the beginning of a vector
    stop = TRUE, # Code vector must end with the specified codes
    tech_names = TRUE # Use long but unique and descriptive variable names
  )
```

The resulting object has only one `regex`-column (named `regex`). It is based on `regex_icd8_brusselaers` but suffixed with `$` (due to `stop = TRUE`). Group names might seem cumbersome but this will help to distinguish column names added by `categorize()` if this function is run repeatedly with different classcodes (if we prefer to calculate both the Charlson and Elixhauser indices for the same patients). The original `charlson` object had `r nrow(charlson)` rows, but `charlson_icd8` has only `r nrow(charlson_icd8)`, since not all groups are defined by that version.

```{r}
charlson_icd8
```

Note that all indices columns remain:

```{r}
names(charlson_icd8)
```

It is thus possible to combine any categorization with any index, although some combinations might be preferred (such as `regex_icd9cm_deyo` combined with `index_deyo_ramano`).

We can now use `charlson_icd8` in a call to classify:

```{r}
classify(410, charlson_icd8, tech_names = FALSE)
```

Thus, the ICD-8 code `410`is recognized only as myocardial infarction.

## Implicit use of `set_classcodes()`

Instead of pre-specifying the `charlson_icd8`, a similar result is achieved by:

```{r}
classify(
  410,
  charlson,
  cc_args = list(
    regex = "icd8_brusselaers", 
    start = FALSE, 
    stop  = TRUE
  )
)
```

... where we decided to drop the `tech_names = TRUE`, however, since that lead to overly complicated column names.
